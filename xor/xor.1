.TH XOR 1 2019-09-05 "xor (development version)" "user commands"

.\"=============================================================================
.SH NAME

xor \- XORs all bytes

.\"=============================================================================
.SH SYNOPSIS

\fBxor\fR [\fIKEYFILE\fR]

.\"=============================================================================
.SH DESCRIPTION

Performs XOR on data provided by stdin with a file \fIKEYFILE\fR, and prints the
resulting data to stdout. The content of \fIKEYFILE\fR is repeated and/or
cropped as necessary to equal the data's length.

If \fIKEYFILE\fR is omitted, \fBxor\fR performs XOR on the data with all bits
set to 1 (i.e. simply all the input bits are swapped).

.\"=============================================================================
.SH EXIT CODE
If the wrong number of arguments (more than 1) is given or the provided
\fIKEYFILE\fR cannot be read (does not exist, or is empty, or no permission),
\fBxor\fR returns \fBEXIT_FAILURE\fR as defined in the C standard library;
otherwise \fBxor\fR returns 0.

.\"=============================================================================
.SH EXAMPLE

.RS 4
xor my_keyfile <my_porn_collection.tgz >my_scrambled_porn_collection_muahaha
.RE

.\"=============================================================================
.SH SECURITY NOTES

If security is any concern, the keyfile's content should have at least the
length of the provided data and be as random as possible. Furthermore, the
keyfile should be stored securely.

To generate a secure keyfile (long and random enough) one can use
\fB/dev/urandom\fR as follows:

.RS 4
xor /dev/urandom <\fIfile\fR >\fIscrambled_file\fR
.RE

The XOR between the scrambled data and the original data is then the keyfile:

.RS 4
xor \fIscrambled_file\fR <\fIfile\fR >\fIkeyfile\fR
.RE

Due to the mathematical property of XOR, one can obviousy consider the keyfile
to be the scrambled file and vice versa as well.
