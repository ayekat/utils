#!/usr/bin/env sh

# Recursively print the reverse dependency tree for packages (similar to
# `aptitude why`).
# Written by ayekat on a cool monday morning in August 2015.

set -e

FALSE=0
TRUE=1
E_SUCCESS=0
E_USER=1
E_GENERAL=2
E_INTERRUPT=127
E_INTERNAL=255
ANSI_BLACK="\033[30m"
ANSI_RED="\033[31m"
ANSI_GREEN="\033[32m"
ANSI_YELLOW="\033[33m"
ANSI_BLUE="\033[34m"
ANSI_RESET="\033[0m"

evilwhy()
(
	text="$1"
	esc_text="$2"
	depth=$3

	# Padding:
	padding="$(printf '%*s' $(($depth * $indent)) ' ')"

	# Text:
	printf "$padding${esc_text}%s${esc_reset}\n" "$text"
)

why()
(
	package="$1"

	# Padding:
	depth=$2
	if [ $depth -eq 0 ]; then
		padding=''
	else
		padding="$(printf '%*s' $(($depth * $indent)) ' ')"
	fi

	# Colour:
	reason="$(expac -Q '%w' "$package")"
	if [ "$reason" = 'explicit' ]; then
		esc_package="$esc_explicit"
	else
		esc_package="$esc_dependency"
	fi

	# Groups:
	if [ $brief -ne $TRUE ]; then
		groups="$(expac -Q '%G' "$package")"
	fi

	# Print:
	printf "$padding${esc_package}%s${esc_reset}" "$package"
	if [ $brief -ne $TRUE ]; then
		for g in $groups; do
			printf ":$esc_group$g$esc_reset"
		done
	fi
	printf "\n"

	# Recursively print reverse dependencies:
	if [ "$reason" = 'dependency' ] || [ $verbose = $TRUE ]; then
		revdeps="$(expac -Q '%N' "$package")"
		if [ $depth -lt $maxdepth ]; then
			if [ -z "$revdeps" ]; then
				if [ "$reason" = 'dependency' ]; then
					evilwhy '<none>' "$esc_warn" $(($depth + 1))
				fi
			else
				for revdep in $revdeps; do
					why "$revdep" $(($depth + 1))
				done
			fi
		else
			evilwhy '...' "$esc_maxdepth" $(($depth + 1))
		fi
	fi
)

die()
{
	retval=$1; shift
	printf "$@" >&2
	echo >&2
	exit $retval
}

help()
{
	cat <<- EOF
	$(basename $0): Show reverse dependency tree for a package

	Usage: $(basename $0) [OPTIONS] PACKAGE [..]

	Options:
	  -b, --brief         Don't show group next to package names
	  -c, --colour WHEN   When to show colours {always,never,auto} [default=$colour]
	  -d, --depth DEPTH   Maximum depth for recursion [default=$maxdepth]
	  -h, --help          Display this help and exit
	  -i, --indent INDENT Number of spaces used for indentation [default=$indent]
	  -v, --verbose       Show revdeps also for explicitely installed packages

	Mandatory arguments for long options are mandatory for short options, too.
	EOF
}

# PROGRAM START

# Argument reading:
brief=$FALSE
colour=auto
maxdepth=5
indent=4
packages=''
verbose=$FALSE
while [ $# -gt 0 ]; do
	case "$1" in
		-b|--brief) brief=$TRUE ;;
		-c|--colour) shift; colour="$1" ;;
		-d|--depth) shift; maxdepth="$1" ;;
		-h|--help) help; exit $E_SUCCESS ;;
		-i|--indent) shift; indent="$1" ;;
		-v|--verbose) verbose=$TRUE ;;
		-*) die $E_USER 'Unknown option: %s' "$1" ;;
		*) packages="$packages $1" ;;
	esac
	shift
done

# Argument checking:
if case "$colour" in (always|never|auto) false ;; esac; then
	die $E_USER 'Invalid colour argument: %s' "$colour"
fi
if ! case "$maxdepth" in (''|*[!0-9]*) false ;; esac; then
	die $E_USER 'Non-integer value for maximum recursion depth: %s' "$maxdepth"
fi
if ! case "$indent" in (''|*[!0-9]*) false ;; esac; then
	die $E_USER 'Non-integer value for indentation: %s' "$indent"
fi

# Colour:
if [ "$colour" = 'auto' ]; then
	if [ -t 1 ] && [ -t 2 ]; then
		colour='always'
	else
		colour='never'
	fi
fi
if [ "$colour" = 'always' ]; then
	esc_group="$ANSI_BLUE"
	esc_explicit="$ANSI_GREEN"
	esc_warn="$ANSI_RED"
	esc_maxdepth="$ANSI_YELLOW"
	esc_reset="$ANSI_RESET"
else
	esc_group=''
	esc_explicit=''
	esc_warn=''
	esc_maxdepth=''
	esc_reset=''
fi

for p in $packages; do
	why "$p" 0
done
