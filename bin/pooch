#!/usr/bin/env sh

# Filter and notify about new mails in a Maildir.
# Written by ayekat on an exceptionally rainy day in january 2018.

set -eu

# Environment:
HOME="${HOME:-$(getent passwd "$(id -un)" | cut -d : -f 6)}"
XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.confg}"
XDG_DATA_HOME="${XDG_DATA_HOME:-$HOME/.local/share}"
XDG_RUNTIME_DIR="${XDG_RUNTIME_DIR:-/run/user/$(id -u)}"
HOSTNAME="$(uname -n)"

# Pooch information:
POOCHNAME=pooch
POOCHCMD="$(basename "$0")"
POOCHTMP="$XDG_RUNTIME_DIR/$POOCHNAME"

# Constants:
E_SUCCESS=0
E_USER=1
E_FILESYSTEM=2
E_EXISTS=4
E_MATCH=5
E_INTERNAL=13
TRUE=1
FALSE=0

# Default values:
basedir="$XDG_DATA_HOME/mail"
folder=INBOX
have_mailpath=$FALSE
debug=$FALSE
testrun=$FALSE

check_rulefile()
(
	headerpath="$1"
	rulefile="$2"

	destfolder="$(head -n1 "$rulefile")"
	debug 'Checking for %s' "$destfolder" >&2
	IFS=
	tail -n +2 "$rulefile" | while read -r rule; do
		if ! grep -E "$rule" "$headerpath" >/dev/null 2>&1; then
			debug '\033[33m→ Rule failed: %s\033[0m' "$rule" >&2
			exit $E_MATCH
		fi
		debug '\033[32m→ Rule matched: %s\033[0m' "$rule" >&2
	done
	debug '\033[32m→ Moving to %s\033[0m' "$destfolder" >&2
	echo "$destfolder"
)

check_rules()
(
	headerpath="$1"
	rulesdir="$XDG_CONFIG_HOME/$POOCHNAME/$account"
	test_directory "$rulesdir" || exit $E_MATCH
	for rulefile in "$rulesdir"/*; do
		test -r "$rulefile" || break # fuck shell globbing
		if destfolder="$(check_rulefile "$headerpath" "$rulefile")"; then
			echo "$destfolder"
			exit $E_SUCCESS
		fi
	done
	exit $E_MATCH
)

extract_header()
(
	mailpath="$1"
	mkdir -p "$POOCHTMP"
	headerpath="$(mktemp "$POOCHTMP/header.XXXXXXXX")" \
		|| die $E_FILESYSTEM 'Could not create temporary file for header'

	# TODO: merge multi-line headers
	nlines=0
	IFS=
	while read -r line; do
		test -n "$line" || break
		nlines=$((nlines + 1))
		echo "$line" >> "$headerpath"
	done <"$mailpath"

	debug 'Stored header (%d lines) as %s' $nlines "$headerpath" >&2
	echo "$headerpath"
)

move()
(
	# There is no atomic way with `mv` for moving a file only if the destination
	# does not exist and failing otherwise. Here we use ln (which *does* fail if
	# the target exists).
	# There is still a (very unlikely) race condition, though: if the underlying
	# filesystem somehow turns read-only between the linking and the removing,
	# we end up with two hard links to the same file. But that is still less bad
	# than overwriting files (and we can cascade an error message up to the user
	# so they can react).
	if [ $testrun -eq $FALSE ]; then
		ln -PT "$1" "$2" || exit $E_EXISTS
		rm "$1" || die $E_FILESYSTEM '%s: Move failed for unknown reasons' "$1"
	fi
	debug 'move %s → %s' "$1" "$2"
)

move_mail()
(
	mailpath="$1"
	destfolderpath="$2"
	timestamp="$(printf '%.5f' "$(date '+%s.%N')")"
	protocol=2 # TODO: what's this?
	flag=S     # TODO: what's this?
	serial=1

	while true; do
		destpath="$destfolderpath/${timestamp}_$serial.$HOSTNAME:$protocol,$flag"
		if ! move "$mailpath" "$destpath"; then
			# Move failed; handle:
			moveretval=$?
			if [ $moveretval -eq $E_EXISTS ]; then
				# Serial number occupied; try next:
				serial=$((serial + 1))
				continue
			else
				# Something went wrong; exit:
				warn 'Could not move %s to %s' "$mailpath" "$destpath"
				exit $moveretval
			fi
		else
			# Move succeeded; we're done:
			break
		fi
	done
)

filter()
{
	# Extract header:
	mailpath="$1"
	headerpath="$(extract_header "$mailpath")"

	# Check rules:
	if ! destfolder="$(check_rules "$headerpath")" \
	|| [ "$destfolder" = "$folder" ]; then
		# No rule matched (or rule puts it in same folder):
		destfolder="$folder"
	else
		# Rule mached:
		destfolderpath="$accountpath/$destfolder/new"
		if ! move_mail "$mailpath" "$destfolderpath"; then
			warn 'Could not move %s to %s' "$mailpath" "$destfolderpath"
			destfolder="$folder"
		fi
	fi

	# Delete header:
	debug 'Removing header %s' "$headerpath"
	rm "$headerpath"

	# Send notification:
	notify "$destfolder"
}

notify()
{
	notify-send "$POOCHNAME ($account)" "$1"
}

test_directory()
(
	if [ "x$1" = 'x-w' ]; then
		shift
		test -w "$1" || die $E_FILESYSTEM '%s: Write permission denied' "$1"
	fi
	test -e "$1" || die $E_FILESYSTEM '%s: Directory not found' "$1"
	test -d "$1" || die $E_FILESYSTEM '%s: Not a directory' "$1"
	test -r "$1" || die $E_FILESYSTEM '%s: Read permission denied' "$1"
	test -x "$1" || die $E_FILESYSTEM '%s: Access denied' "$1"
)

die()
{
	retval=$(($1 + 0)); shift
	printf "$@" >&2; echo >&2
	if [ $retval -eq $E_USER ]; then
		printf 'Run with -h for more information.\n' >&2
	fi
	exit $retval
}

warn()
{
	printf "$@" >&2
	echo >&2
}

debug()
{
	if [ $debug -eq $TRUE ]; then
		printf "$@"
		echo
	fi
}

print_help()
{
	cat <<- EOF
	$POOCHCMD: Filter and notify about new mails

	Usage: $POOCHCMD [OPTION...] ACCOUNT

	Options:
	  -b PATH    Use PATH as base directory for accounts [default=$basedir]
	  -d         Enable debug mode
	  -h         Display this help and exit
	  -m FILE    Handle mail file FILE and then exit
	  -t         Test run (don't actually rename files, but only print)
	  -w FOLDER  Watch FOLDER for new mails [default=$folder]
	EOF
}

# Read command line options:
while getopts :b:dhm:tw: opt; do
	case "$opt" in
		(b) basedir="$OPTARG" ;;
		(d) debug=$TRUE; debug 'Displaying debug messages' ;;
		(h) print_help; exit $E_SUCCESS ;;
		(m) have_mailpath=$TRUE; mailpath="$OPTARG" ;;
		(t) testrun=$TRUE ;;
		(w) folder="$OPTARG" ;;
		(:) die $E_USER 'Missing argument for -%s' "$OPTARG" ;;
		('?') die $E_USER 'Unknown option -%s' "$OPTARG" ;;
		(*) die $E_INTERNAL 'Unhandled option -%s' "$OPTARG" ;;
	esac
	unset opt OPTARG
done
shift $((OPTIND - 1))
test $# -gt 0 || die $E_USER 'Please specify an account'
account="$1"; shift
test $# -eq 0 || die $E_USER 'Trailing arguments: %s' "$*"

# Check command line options:
test -n "$basedir" || die $E_USER 'Please specify a non-empty base directory'
test -n "$folder" || die $E_USER 'Please specify a non-empty folder name'
test -n "$account" || die $E_USER 'Please specify a non-empty account name'
case "$account" in (*/*) die $E_USER 'Invalid account name: %s' "$account"; esac

# Assemble paths:
test_directory -w "$basedir" || exit $?
accountpath="$(readlink -f "$basedir/$account")"
test_directory -w "$accountpath" || exit $?

# One-time?
if [ $have_mailpath -eq $TRUE ]; then
	mailpath="$(readlink -f "$mailpath")"
	test -n "$mailpath" || die $E_USER 'Please specify a non-empty file name'
	test -e "$mailpath" || die $E_USER '%s: File not found' "$mailpath"
	test -r "$mailpath" || die $E_USER '%s: Read permission denied' "$mailpath"
	filter "$mailpath"
	exit $E_SUCCESS
fi

folderpath="$(readlink -f "$accountpath/$folder/new")"
test_directory -w "$folderpath" || exit $?

# Watch directory:
test $debug -eq $TRUE || quietarg='--quiet'
inotifywait \
	${quietarg:-} \
	--monitor \
	--event moved_to \
	--format '%w%f' \
	"$folderpath" \
| while read -r mailpath; do
	filter "$mailpath"
done
