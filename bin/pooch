#!/usr/bin/env sh

# Filter and notify about new mails in a Maildir.
# Written by ayekat on an exceptionally rainy day in january 2018.

set -eu

# Environment:
HOME="${HOME:-$(getent passwd "$(id -un)" | cut -d : -f 6)}"
XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.confg}"
XDG_DATA_HOME="${XDG_DATA_HOME:-$HOME/.local/share}"
XDG_RUNTIME_DIR="${XDG_RUNTIME_DIR:-/run/user/$(id -u)}"
HOSTNAME="$(uname -n)"

# Pooch information:
POOCHNAME=pooch
POOCHCMD="$(basename "$0")"
POOCHTMP="$XDG_RUNTIME_DIR/$POOCHNAME"

# Constants:
E_SUCCESS=0
E_USER=1
E_FILESYSTEM=2
E_EXISTS=4
E_MATCH=5
E_INTERNAL=13
TRUE=1
FALSE=0

# Default values:
basepath="$XDG_DATA_HOME/mail"
folder=INBOX
have_mailpath=$FALSE
debug=$FALSE
keep_headers=$FALSE
testrun=$FALSE

check_rulefile()
(
	headerpath="$1"
	rulefile="$2"

	# Destination folder for this rule:
	destfolder="$(head -n1 "$rulefile")"
	debug 'Checking for %s' "$destfolder" >&2

	# Rule lines:
	IFS=
	tail -n +2 "$rulefile" | while read -r rule; do
		if ! grep -E "$rule" "$headerpath" >/dev/null 2>&1; then
			debug '\033[33m→ Rule failed: %s\033[0m' "$rule" >&2
			exit $E_MATCH
		fi
		debug '\033[32m→ Rule matched: %s\033[0m' "$rule" >&2
	done
	debug '\033[32m→ Moving to %s\033[0m' "$destfolder" >&2
	echo "$destfolder"
)

check_rules()
(
	headerpath="$1"
	rulesdir="$XDG_CONFIG_HOME/$POOCHNAME/$account"
	test_directory "$rulesdir" || exit $E_MATCH
	for rulefile in "$rulesdir"/*; do
		test -r "$rulefile" || break # fuck shell globbing
		if destfolder="$(check_rulefile "$headerpath" "$rulefile")"; then
			echo "$destfolder"
			exit $E_SUCCESS
		fi
	done
	exit $E_MATCH
)

extract_header()
(
	mailpath="$1"
	mkdir -p "$POOCHTMP"
	headerpath="$(mktemp "$POOCHTMP/header.XXXXXXXX")" \
		|| die $E_FILESYSTEM 'Could not create temporary file for header'

	nlines=0
	lastline=''
	IFS=
	while read -r line; do
		case "$line" in
			(\ *|\	*)
				# Indented line, append to previous line:
				lastline="$lastline$line" ;;
			(*)
				# Regular line, commit previous line to file:
				echo "$lastline" >>"$headerpath"
				nlines=$((nlines + 1))
				lastline="$line" ;;
		esac

		# Empty line, we're done:
		test -n "$line" || break
	done <"$mailpath"

	debug 'Stored header (%d lines) as %s' $nlines "$headerpath" >&2
	echo "$headerpath"
)

move()
(
	# There is no atomic way with `mv` for moving a file only if the destination
	# does not exist and failing otherwise. Here we use ln (which *does* fail if
	# the target exists). There are still (very unlikely) race conditions,
	# though:
	# 1. If the underlying filesystem somehow turns read-only between the
	#    linking and the removing, we end up with two hard links to the same
	#    file. This is still less of a problem than overwriting files, though
	#    (and we can cascade an error message up to the user so they can react).
	# 2. 1. Target does not exist
	#    2. `ln` fails for a different reason
	#    3. Target is created
	#    4. We check for its existence
	#    5. Target exists, so we return E_EXISTS
	if [ $testrun -eq $FALSE ]; then
		if ! ln -PT "$1" "$2"; then
			if [ -e "$2" ]; then
				exit $E_EXISTS
			else
				exit $E_FILESYSTEM
			fi
		fi
		rm "$1" || exit $E_FILESYSTEM
	fi
	debug 'move %s → %s' "$1" "$2"
)

move_mail()
(
	mailpath="$1"
	destfolderpath="$2"
	timestamp="$(printf '%.5f' "$(date '+%s.%N')")"
	protocol=2 # XXX: what's this?
	flag=''    # TODO: adopt from original file

	test_directory -w "$destfolderpath" || exit $?

	# Given the race condition in move() that may cause this to turn infinitly,
	# we set an upper limit for serial numbers (so no `while true`):
	for serial in $(seq 1 1024); do
		destpath="$destfolderpath/${timestamp}_$serial.$HOSTNAME:$protocol,$flag"

		moveretval=$E_SUCCESS
		move "$mailpath" "$destpath" || moveretval=$?

		case $moveretval in
			($E_SUCCESS)
				# Move succeeded; we're done:
				exit $E_SUCCESS ;;
			($E_EXISTS)
				# File exists; try next serial:
				continue ;;
			($E_FILESYSTEM)
				# Some other FS-related issue; abort:
				warn 'Could not move %s → %s' "$mailpath" "$destpath"
				exit $moveretval
		esac
	done
	die $E_INTERNAL 'Aborted: Serial number exceeded maximum'
)

filter()
{
	# Extract header:
	mailpath="$1"
	headerpath="$(extract_header "$mailpath")"

	# Check rules:
	if ! destfolder="$(check_rules "$headerpath")" \
	|| [ "$destfolder" = "$folder" ]; then
		# No rule matched (or rule puts it in same folder):
		destfolder="$folder"
	else
		# Rule mached:
		destfolderpath="$accountpath/$destfolder/new"
		if ! move_mail "$mailpath" "$destfolderpath"; then
			warn 'Could not move %s to %s' "$mailpath" "$destfolderpath"
			destfolder="$folder"
		fi
	fi

	# Delete header:
	if [ $keep_headers -eq $TRUE ]; then
		debug 'Keeping header %s' "$headerpath"
	else
		debug 'Removing header %s' "$headerpath"
		rm "$headerpath"
	fi

	# Send notification:
	notify "$destfolder"
}

notify()
{
	notify-send "New Mail ($account)" "$1"
}

test_directory()
(
	writable=$FALSE
	if [ "x$1" = 'x-w' ]; then
		writable=$TRUE
		shift
	fi
	test -e "$1" || die $E_FILESYSTEM '%s: Directory does not exist' "$1"
	test -d "$1" || die $E_FILESYSTEM '%s: Not a directory' "$1"
	test -r "$1" || die $E_FILESYSTEM '%s: Read permission denied' "$1"
	if [ $writable -eq $TRUE ]; then
		test -w "$1" || die $E_FILESYSTEM '%s: Write permission denied' "$1"
	fi
	test -x "$1" || die $E_FILESYSTEM '%s: Access denied' "$1"
)

die()
{
	retval=$(($1 + 0)); shift
	printf "$@" >&2; echo >&2
	if [ $retval -eq $E_USER ]; then
		printf 'Run with -h for more information.\n' >&2
	fi
	exit $retval
}

warn()
{
	printf "$@" >&2
	echo >&2
}

debug()
{
	if [ $debug -eq $TRUE ]; then
		printf "$@"
		echo
	fi
}

print_help()
{
	cat <<- EOF
	$POOCHCMD: Filter and notify about new mails

	Usage: $POOCHCMD [OPTION...] ACCOUNT

	Options:
	  -b PATH    Use PATH as base directory for accounts [default=$basepath]
	  -d         Enable debug mode
	  -h         Display this help and exit
	  -k         Don't delete headers from $POOCHTMP after processing mails
	  -m FILE    Handle mail file FILE and then exit
	  -t         Test run (don't actually rename files, but only print)
	  -w FOLDER  Watch FOLDER for new mails [default=$folder]
	EOF
}

# Read command line options:
while getopts :b:dhkm:tw: opt; do
	case "$opt" in
		(b) basepath="$OPTARG" ;;
		(d) debug=$TRUE; debug 'Displaying debug messages' ;;
		(h) print_help; exit $E_SUCCESS ;;
		(k) keep_headers=$TRUE ;;
		(m) have_mailpath=$TRUE; mailpath="$OPTARG" ;;
		(t) testrun=$TRUE ;;
		(w) folder="$OPTARG" ;;
		(:) die $E_USER 'Missing argument for -%s' "$OPTARG" ;;
		('?') die $E_USER 'Unknown option -%s' "$OPTARG" ;;
		(*) die $E_INTERNAL 'Unhandled option -%s' "$OPTARG" ;;
	esac
	unset opt OPTARG
done
shift $((OPTIND - 1))
test $# -gt 0 || die $E_USER 'Please specify an account'
account="$1"; shift
test $# -eq 0 || die $E_USER 'Trailing arguments: %s' "$*"

# Check command line options:
test -n "$basepath" || die $E_USER 'Please specify a non-empty base directory path'
test -n "$folder" || die $E_USER 'Please specify a non-empty folder name'
test -n "$account" || die $E_USER 'Please specify a non-empty account name'
case "$account" in (*/*) die $E_USER 'Invalid account name: %s' "$account"; esac

# Assemble paths:
test_directory -w "$basepath" || exit $?
accountpath="$(readlink -f "$basepath/$account")"
test_directory -w "$accountpath" || exit $?

# One-time?
if [ $have_mailpath -eq $TRUE ]; then
	mailpath="$(readlink -f "$mailpath")"
	test -n "$mailpath" || die $E_USER 'Please specify a non-empty file name'
	test -e "$mailpath" || die $E_USER '%s: File not found' "$mailpath"
	test -r "$mailpath" || die $E_USER '%s: Read permission denied' "$mailpath"
	filter "$mailpath"
	exit $E_SUCCESS
fi

folderpath="$(readlink -f "$accountpath/$folder/new")"
test_directory -w "$folderpath" || exit $?

# Watch directory:
test $debug -eq $TRUE || quietarg='--quiet'
inotifywait \
	${quietarg:-} \
	--monitor \
	--event moved_to \
	--format '%w%f' \
	"$folderpath" \
| while read -r mailpath; do
	filter "$mailpath"
done
